from __future__ import annotations

import logging
import time
from typing import List, Optional, Tuple

from ytmusicapi import YTMusic

from .config import Settings
from .lastfm import Scrobble, fetch_recent_with_diversity
from .recency import WeightedTrack, collapse_recency_weighted, dedupe_keep_latest, unique_preserve_order
from .search import find_on_ytm, log_search_statistics, reset_search_statistics, get_search_statistics
from .ytm_client import build_oauth_client, create_playlist_with_items, get_existing_playlist_by_name
from .playlist import sync_playlist, reset_query_counter as reset_playlist_counter, log_playlist_statistics, get_playlist_statistics

from .weekly import update_weekly_playlist

log = logging.getLogger(__name__)


def _resolve_tracks_to_video_ids(
    ytm_search: YTMusic,
    tracks: List[Scrobble | WeightedTrack],
    sleep_between: float,
    early_termination_score: float,
) -> Tuple[List[str], int]:
    video_ids: List[str] = []
    misses = 0
    cache: dict[Tuple[str, str], Optional[str]] = {}
    total_tracks = len(tracks)

    for index, t in enumerate(tracks, start=1):
        artist = t.artist  # type: ignore[attr-defined]
        title = t.track  # type: ignore[attr-defined]
        album = getattr(t, "album", None)
        key = (artist.lower(), title.lower())

        vid = cache.get(key)
        if vid is None:
            vid = find_on_ytm(ytm_search, artist, title, album, early_termination_score)
            cache[key] = vid
            time.sleep(max(0.0, sleep_between))

        if vid:
            video_ids.append(vid)
            if isinstance(t, WeightedTrack):
                log.info("%d/%d Song: %s, Plays: %d, Score: %.4f", index, total_tracks, t.track, t.plays, t.score)
            else:
                log.info("%d/%d Song: %s", index, total_tracks, t.track)
        else:
            misses += 1
            album_info = f" (album: {album})" if album else ""
            log.warning("%d/%d Not found: %s - %s%s", index, total_tracks, artist, title, album_info)

    return video_ids, misses


def run(settings: Settings) -> None:

    log.info("Authenticating YTMusic with OAuth file: %s", settings.ytm_auth_path)
    ytm = build_oauth_client(settings.ytm_auth_path)
    ytm_search = ytm if not settings.use_anon_search else YTMusic()

    reset_search_statistics()
    reset_playlist_counter()

    log.info("Fetching up to %d recent scrobbles for '%s' ...", settings.limit, settings.lastfm_user)
    recents: List[Scrobble] = fetch_recent_with_diversity(settings.lastfm_user, settings.lastfm_api_key, settings.limit)
    if not recents:
        log.warning("No recent scrobbles found. Exiting.")
        return

    if settings.use_recency_weighting:
        tracks: List[WeightedTrack] = collapse_recency_weighted(
            recents,
            half_life_hours=settings.recency_half_life_hours,
            max_unique=settings.recency_max_unique,
        )
        log.info(
            "Aggregated to %d unique tracks (half-life=%.1fh). Resolving on YTM...",
            len(tracks),
            settings.recency_half_life_hours,
        )
    else:
        ordered = sorted(recents, key=lambda x: x.ts, reverse=True)
        tracks = dedupe_keep_latest(ordered) if settings.deduplicate else ordered  # type: ignore[assignment]
        log.info(
            "Prepared %d tracks (%s). Resolving on YTM...",
            len(tracks),
            "deduped" if settings.deduplicate else "with repeats",
        )

    video_ids, misses = _resolve_tracks_to_video_ids(ytm_search, tracks, settings.sleep_between_searches, settings.early_termination_score)
    valid_video_ids = [vid for vid in video_ids if isinstance(vid, str) and len(vid) == 11]
    valid_video_ids = unique_preserve_order(valid_video_ids)

    if not valid_video_ids:
        log.warning("No valid video IDs resolved. Exiting.")
        return

    desc = (
        f"Autogenerated from Last.fm recents for {settings.lastfm_user}. "
        f"{'Recency-weighted order (half-life=' + str(settings.recency_half_life_hours) + 'h).' if settings.use_recency_weighting else 'Most recent first.'}"
    )

    existing_id = get_existing_playlist_by_name(ytm, settings.playlist_name)
    if existing_id:
        log.info("Updating existing playlist '%s' (%s) ...", settings.playlist_name, existing_id)
        try:
            ytm.edit_playlist(
                existing_id,
                title=settings.playlist_name,
                description=desc,
                privacyStatus=settings.privacy_status,
            )
        except Exception:
            pass
        try:
            sync_playlist(ytm, existing_id, valid_video_ids)
        except Exception as e:
            log.error("Update failed: %s", e)
            return
        pl_id = existing_id
    else:
        log.info("Creating playlist '%s' (privacy=%s) ...", settings.playlist_name, settings.privacy_status)
        try:
            pl_id = create_playlist_with_items(
                ytm,
                settings.playlist_name,
                desc,
                settings.privacy_status,
                valid_video_ids,
            )
        except Exception as e:
            log.error("Create failed: %s", e)
            return

    weekly_id = update_weekly_playlist(
        ytm,
        get_existing_playlist_by_name,
        create_playlist_with_items,
        sync_playlist,
        settings=settings,
        valid_video_ids=valid_video_ids,
        base_desc=desc,
    )

    log.info("Done. Playlist ID: %s", pl_id)
    log.info("Open: https://music.youtube.com/playlist?list=%s", pl_id)
    if weekly_id:
        log.info("Weekly playlist ID: %s", weekly_id)
        log.info("Open: https://music.youtube.com/playlist?list=%s", weekly_id)
    if misses:
        log.info("%d tracks not found on YTM search.", misses)
    
    log_search_statistics()
    log_playlist_statistics()
    search_stats = get_search_statistics()
    playlist_stats = get_playlist_statistics()
    
    total_api_calls = search_stats.get('total_queries', 0) + playlist_stats.get('total_queries', 0)
    total_duration = max(search_stats.get('session_duration', 0), playlist_stats.get('session_duration', 0))
    
    log.info("=== Combined Session Summary ===")
    log.info("Total API calls this session: %d", total_api_calls)
    log.info("Search queries: %d (%.1f%%)", 
             search_stats.get('total_queries', 0),
             100.0 * search_stats.get('total_queries', 0) / total_api_calls if total_api_calls > 0 else 0)
    log.info("Playlist queries: %d (%.1f%%)", 
             playlist_stats.get('total_queries', 0),
             100.0 * playlist_stats.get('total_queries', 0) / total_api_calls if total_api_calls > 0 else 0)
    
    if total_duration > 0:
        log.info("Overall API rate: %.2f calls/second", total_api_calls / total_duration)
    
    log.info("=================================")
