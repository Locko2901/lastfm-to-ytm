from __future__ import annotations

import logging
import time
from typing import List, Optional, Tuple

from ytmusicapi import YTMusic

from .config import Settings
from .lastfm import Scrobble, fetch_recent
from .recency import WeightedTrack, collapse_recency_weighted, dedupe_keep_latest, unique_preserve_order
from .search import find_on_ytm
from .ytm_client import build_oauth_client, create_playlist_with_items, get_existing_playlist_by_name
from .playlist import minimal_diff_update

log = logging.getLogger(__name__)

def _resolve_tracks_to_video_ids(
    ytm_search: YTMusic,
    tracks: List[Scrobble | WeightedTrack],
    sleep_between: float,
) -> Tuple[List[str], int]:
    video_ids: List[str] = []
    misses = 0
    cache: dict[Tuple[str, str], Optional[str]] = {}

    for t in tracks:
        artist = t.artist  # type: ignore[attr-defined]
        title = t.track  # type: ignore[attr-defined]
        album = getattr(t, "album", None)
        key = (artist.lower(), title.lower())

        vid = cache.get(key)
        if vid is None:
            vid = find_on_ytm(ytm_search, artist, title, album)
            cache[key] = vid
            time.sleep(max(0.0, sleep_between))

        if vid:
            video_ids.append(vid)
            if isinstance(t, WeightedTrack):
                log.info("Song: %s, Plays: %d, Score: %.4f", t.track, t.plays, t.score)
        else:
            misses += 1
            album_info = f" (album: {album})" if album else ""
            log.warning("Not found: %s - %s%s", artist, title, album_info)

    return video_ids, misses


def run(settings: Settings) -> None:

    log.info("Authenticating YTMusic with OAuth file: %s", settings.ytm_auth_path)
    ytm = build_oauth_client(settings.ytm_auth_path)
    ytm_search = ytm if not settings.use_anon_search else YTMusic()

    log.info("Fetching up to %d recent scrobbles for '%s' ...", settings.limit, settings.lastfm_user)
    recents: List[Scrobble] = fetch_recent(settings.lastfm_user, settings.lastfm_api_key, settings.limit)
    if not recents:
        log.warning("No recent scrobbles found. Exiting.")
        return

    if settings.use_recency_weighting:
        tracks: List[WeightedTrack] = collapse_recency_weighted(
            recents,
            half_life_hours=settings.recency_half_life_hours,
            max_unique=settings.recency_max_unique,
        )
        log.info("Aggregated to %d unique tracks (half-life=%.1fh). Resolving on YTM...", len(tracks), settings.recency_half_life_hours)
    else:
        ordered = sorted(recents, key=lambda x: x.ts, reverse=True)
        tracks = dedupe_keep_latest(ordered) if settings.deduplicate else ordered  # type: ignore[assignment]
        log.info("Prepared %d tracks (%s). Resolving on YTM...", len(tracks), "deduped" if settings.deduplicate else "with repeats")

    video_ids, misses = _resolve_tracks_to_video_ids(ytm_search, tracks, settings.sleep_between_searches)
    valid_video_ids = [vid for vid in video_ids if isinstance(vid, str) and len(vid) == 11]
    valid_video_ids = unique_preserve_order(valid_video_ids)

    if not valid_video_ids:
        log.warning("No valid video IDs resolved. Exiting.")
        return

    desc = (
        f"Autogenerated from Last.fm recents for {settings.lastfm_user}. "
        f"{'Recency-weighted order (half-life=' + str(settings.recency_half_life_hours) + 'h).' if settings.use_recency_weighting else 'Most recent first.'}"
    )

    existing_id = get_existing_playlist_by_name(ytm, settings.playlist_name)
    if existing_id:
        log.info("Updating existing playlist '%s' (%s) ...", settings.playlist_name, existing_id)
        try:
            ytm.edit_playlist(existing_id, title=settings.playlist_name, description=desc, privacyStatus=settings.privacy_status)
        except Exception:
            pass
        try:
            minimal_diff_update(ytm, existing_id, valid_video_ids)
        except Exception as e:
            log.error("Update failed: %s", e)
            return
        pl_id = existing_id
    else:
        log.info("Creating playlist '%s' (privacy=%s) ...", settings.playlist_name, settings.privacy_status)
        try:
            pl_id = create_playlist_with_items(ytm, settings.playlist_name, desc, settings.privacy_status, valid_video_ids)
        except Exception as e:
            log.error("Create failed: %s", e)
            return

    log.info("Done. Playlist ID: %s", pl_id)
    log.info("Open: https://music.youtube.com/playlist?list=%s", pl_id)
    if misses:
        log.info("%d tracks not found on YTM search.", misses)
